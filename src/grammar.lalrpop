// LALRPOP grammar for the VM front-end.
//
// Adapted from that found in the `amath` crate, with heavy additions.
// https://github.com/vpzomtrrfrt/amath/blob/master/src/grammar.lalrpop

use crate::ast;
use std::str::FromStr;


grammar;


// Statement rules.
pub Statement: ast::Statement = {
    <name:Id> "<-" <exprs:ExprList> ";" => ast::emit(name.as_str(), exprs),
    "let" <name:Id> "=" <value:Expr> ";" => ast::def(name.as_str(), value),
    <e: SimpleExpr> ";" => ast::expr_for_effect(e),
    "func" <name:Id> <args:Arglist> "->" <ret:Type> <body:Block> =>
        ast::def(name.as_str(), ast::lambda(args, ret, body)),
    "proc" <name:Id> <args:Arglist> <body:Block> =>
        ast::def(name.as_str(), ast::lambda(args, ast::TypeTag::Unit, body)),
    "for" <name:Id> "in" <list:Expr> <body:Block> =>
        ast::list_iter(name.as_str(), list, ast::expr_for_effect(body)),
    "for" "(" <key:Id> "," <value:Id> ")" "in" <map:Expr> <body:Block> =>
        ast::map_iter(key.as_str(), value.as_str(), map, ast::expr_for_effect(body)),
}


// Expression entry point.
pub Expr: ast::Expr = {
    Block,
    SimpleExpr,
}


pub Type: ast::TypeTag = {
    "Bool" => ast::TypeTag::Bool,
    "Int" => ast::TypeTag::Int,
    "Float" => ast::TypeTag::Float,
    "Str" => ast::TypeTag::Str,
    "Point" => ast::TypeTag::Point,
    "List" "<" <item:Type> ">" => ast::TypeTag::List(ast::Node::new(item)),
    "Map" "<" <items:(<Str> ":" <Type>)*> ">" =>
        ast::TypeTag::Map(ast::to_map(items)),
    // TODO: Union
    // TODO?: Unit / None?
    // TODO?: Maybe type
}


SimpleExpr: ast::Expr = {
    Lambda,
    Guard,
    Logic,
}


// An if-else chain for statements
Guard: ast::Expr =
    "if"
    <first:GuardClause>
    <rest:("elif" <GuardClause>)*>
    <default:("else" <Block>)?>
    => {
        let mut clauses = vec!{first};
        clauses.extend(rest);
        ast::cond(clauses, default.unwrap_or(ast::Expr::Unit))
    };



// Single clause in an if-else chain
GuardClause: (ast::Expr, ast::Expr) = {
    "(" <pred: Expr> ")" <body: Block>
        => (pred, body),
}


Param: (String, ast::TypeTag) =
    <name:Id> ":" <t:Type> => (name, t);


Arglist: Vec<(String, ast::TypeTag)> =
    "(" <args:Comma<Param>> ")" => args;


Lambda: ast::Expr = <args:Arglist> <ret:("->" <Type>)?> <body:Expr>
    => ast::lambda(args, ret.unwrap_or(ast::TypeTag::Unit), body);

// A block expression must contain a single, trailing return statement
// which will be the value of the block.
Block: ast::Expr = {
    "{" <stmts:Statement+> <ret:("yield" <SimpleExpr>)?> "}"
        => ast::expr_block(stmts, ret.unwrap_or(ast::Expr::Unit)),
    "{" <ret:("yield" <SimpleExpr>)> "}" => ret,
}


// Expression entry point anow, this is the logic operators. This way
// sloppily-parenthesized logic hould do the least surprising thing.
Logic: ast::Expr = {
    <a:Logic> "and" <b:Rel> => ast::bin(ast::BinOp::And, a, b),
    <a:Logic> "or"  <b:Rel> => ast::bin(ast::BinOp::Or, a, b),
    <a:Logic> "xor" <b:Rel> => ast::bin(ast::BinOp::Xor, a, b),
    Rel
}


// Relational operators are the next highest precedence.
Rel: ast::Expr = {
    <a:Rel> "<"  <b:Sum> => ast::bin(ast::BinOp::Lt, a, b),
    <a:Rel> ">"  <b:Sum> => ast::bin(ast::BinOp::Gt, a, b),
    <a:Rel> "<=" <b:Sum> => ast::bin(ast::BinOp::Lte, a, b),
    <a:Rel> ">=" <b:Sum> => ast::bin(ast::BinOp::Gte, a, b),
    <a:Rel> "==" <b:Sum> => ast::bin(ast::BinOp::Eq, a, b),
    Sum
};


Sum: ast::Expr = {
    <a:Sum> "+" <b:Factor> => ast::bin(ast::BinOp::Add, a, b),
    <a:Sum> "-" <b:Factor> => ast::bin(ast::BinOp::Sub, a, b),
    Factor,
};


Factor: ast::Expr = {
    <a:Factor> "*" <b:Term> => ast::bin(ast::BinOp::Mul, a, b),
    <a:Factor> "/" <b:Term> => ast::bin(ast::BinOp::Div, a, b),
    Exp
};


Exp: ast::Expr = {
    <base:Exp> "^" <exp: InvTerm> => ast::bin(ast::BinOp::Pow, base, exp),
    InvTerm
}


// We want these unary operators applied to a function call to do the
// right thing. I.e. -foo() should parse as (- (foo)), not ((- foo)).
//
// The same thing applies to logical negation.
InvTerm: ast::Expr = {
    "-" <a:InvTerm> => ast::un(ast::UnOp::Neg, a),
    "not" <a:InvTerm> => ast::un(ast::UnOp::Not, a),
    Call
};


// We want indexing and selection to bind before function calls, so that
// foo.bar(a) parses as ((dot foo bar) a), not (dot foo (bar a))
Call: ast::Expr = {
    <func:Call> "(" <args:ExprList> ")" => ast::call(func, args),
    Selection
}


// XXX: Would like to allow an arbitrary expression to apear LHS
// without parens; however, this results in ambiguity that LALRPOP
// can't handle.
Selection: ast::Expr = {
    <obj:Selection> "." <id:Id> => ast::dot(obj, id.as_str()),
    <obj:Selection> "[" <e:Expr> "]" => ast::index(obj, e),
    Term
}


// This is the level of literals of any type, including lambdas.
Term: ast::Expr = {
    Id => ast::Expr::Id(<>),
    Int => ast::Expr::Int(<>),
    Float => ast::Expr::Float(<>),
    Str => ast::Expr::Str(<>),
    Boolean => ast::Expr::Bool(<>),
    "(" <a:Expr> ")" => a,
    "[" <l:ExprList> "]" => ast::list(l),
    "{" <m:MapItems> "}" => ast::map(m),
};


// A single item in a map.
MapItem: (String, ast::Expr) = {
    <k:Str> ":" <v:Logic> => (k, v)
}


Int: i64 = r"-?[0-9]+" => i64::from_str(<>).unwrap();
Float: f64 = r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap();
Id: String = r"[A-Za-z_][A-Za-z0-9_]*" => <>.to_owned();
Boolean: bool = {"true" => true, "false" => false};
Str: String = <s:r#""(([^\\"]|\\.)*)""#> => s[1..(s.len() - 1)].to_string();


// Factor out comma-separated lists of things.
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


// Semi-colon separated lists of things.
Semicolon<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


// Any commma-separated list of values.
ExprList = Comma<Expr>;


// So far only used in maps.
MapItems = Comma<MapItem>;
